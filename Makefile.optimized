# Optimized Makefile additions for faster deployment

# Cache directory for Lambda layers
LAYER_CACHE := .layer-cache
LAYER_HASH := $(shell md5 lambdas/layers/requirements.txt 2>/dev/null || echo "no-hash")
CACHED_LAYER := $(LAYER_CACHE)/$(LAYER_HASH).zip

# Fast deployment (skip unnecessary steps)
fast-deploy: check-layer-cache package-lambdas-parallel tf-apply-parallel
	@echo "âœ… Fast deployment completed"

# Check and use cached layer if requirements haven't changed
check-layer-cache:
	@if [ -f "$(CACHED_LAYER)" ]; then \
		echo "âœ… Using cached Lambda layer from $(CACHED_LAYER)"; \
		cp $(CACHED_LAYER) lambdas/layers/dist/ai-ppt-assistant-dependencies.zip; \
	else \
		echo "ðŸ“¦ Building new Lambda layer..."; \
		$(MAKE) build-layers; \
		mkdir -p $(LAYER_CACHE); \
		cp lambdas/layers/dist/ai-ppt-assistant-dependencies.zip $(CACHED_LAYER); \
	fi

# Parallel Lambda packaging
package-lambdas-parallel:
	@echo "Packaging Lambda functions in parallel..."
	@# Package API functions in parallel
	@for func in lambdas/api/*.py; do \
		if [ -f "$$func" ]; then \
			base=$$(basename $$func .py); \
			( \
				echo "Packaging API function: $$base..."; \
				rm -f lambdas/api/$$base.zip; \
				cp $$func /tmp/$$base.py; \
				cd lambdas && zip -qr api/$$base.zip -j /tmp/$$base.py && \
				zip -qr api/$$base.zip utils/ -x "*.pyc" -x "*__pycache__*" && \
				cd - > /dev/null; \
				rm -f /tmp/$$base.py; \
				echo "âœ… $$base packaged"; \
			) & \
		fi \
	done; \
	wait
	@# Package controller functions in parallel
	@for func in lambdas/controllers/*.py; do \
		if [ -f "$$func" ]; then \
			base=$$(basename $$func .py); \
			( \
				echo "Packaging controller function: $$base..."; \
				rm -f lambdas/controllers/$$base.zip; \
				cp $$func /tmp/$$base.py; \
				cd lambdas && zip -qr controllers/$$base.zip -j /tmp/$$base.py && \
				zip -qr controllers/$$base.zip utils/ -x "*.pyc" -x "*__pycache__*" && \
				cd - > /dev/null; \
				rm -f /tmp/$$base.py; \
				echo "âœ… $$base packaged"; \
			) & \
		fi \
	done; \
	wait
	@echo "âœ… All Lambda functions packaged in parallel"

# Terraform apply with parallelism
tf-apply-parallel:
	cd infrastructure && $(TERRAFORM) apply \
		-var="project_name=$(PROJECT_NAME)" \
		-var="aws_region=$(AWS_REGION)" \
		-parallelism=20 \
		-auto-approve
	@echo "âœ… Infrastructure deployed with parallelism"

# Skip test Lambda functions in production deployment
package-lambdas-prod:
	@echo "Packaging production Lambda functions only..."
	@for func in lambdas/api/*.py; do \
		if [ -f "$$func" ]; then \
			base=$$(basename $$func .py); \
			echo "Packaging API function: $$base..."; \
			rm -f lambdas/api/$$base.zip; \
			cp $$func /tmp/$$base.py; \
			cd lambdas && zip -qr api/$$base.zip -j /tmp/$$base.py && zip -qr api/$$base.zip utils/ -x "*.pyc" -x "*__pycache__*" && cd - > /dev/null; \
			rm -f /tmp/$$base.py; \
		fi \
	done
	@for func in lambdas/controllers/*.py; do \
		if [ -f "$$func" ] && [[ ! "$$func" =~ "test_" ]]; then \
			base=$$(basename $$func .py); \
			echo "Packaging controller function: $$base..."; \
			rm -f lambdas/controllers/$$base.zip; \
			cp $$func /tmp/$$base.py; \
			cd lambdas && zip -qr controllers/$$base.zip -j /tmp/$$base.py && zip -qr controllers/$$base.zip utils/ -x "*.pyc" -x "*__pycache__*" && cd - > /dev/null; \
			rm -f /tmp/$$base.py; \
		fi \
	done
	@echo "âœ… Production Lambda functions packaged"

# Production deployment (skip test functions)
deploy-prod: clean check-layer-cache package-lambdas-prod package-infrastructure-lambdas tf-apply-parallel
	@echo "âœ… Production deployment completed"

# Incremental deployment (only changed functions)
deploy-incremental:
	@echo "Detecting changed Lambda functions..."
	@git diff --name-only HEAD lambdas/ | grep -E '\.py$$' | while read file; do \
		if [[ "$$file" =~ lambdas/(api|controllers)/(.+)\.py ]]; then \
			dir=$$(dirname $$file); \
			base=$$(basename $$file .py); \
			echo "Repackaging changed function: $$base"; \
			rm -f $$dir/$$base.zip; \
			cp $$file /tmp/$$base.py; \
			cd lambdas && zip -qr $${dir#lambdas/}/$$base.zip -j /tmp/$$base.py && \
			zip -qr $${dir#lambdas/}/$$base.zip utils/ -x "*.pyc" -x "*__pycache__*" && \
			cd - > /dev/null; \
			rm -f /tmp/$$base.py; \
		fi \
	done
	cd infrastructure && $(TERRAFORM) apply \
		-var="project_name=$(PROJECT_NAME)" \
		-var="aws_region=$(AWS_REGION)" \
		-parallelism=20 \
		-target=module.lambda \
		-auto-approve
	@echo "âœ… Incremental deployment completed"

# Clean layer cache
clean-layer-cache:
	rm -rf $(LAYER_CACHE)
	@echo "âœ… Layer cache cleaned"

# Docker-based layer build (ensures Python 3.12 compatibility)
build-layers-docker:
	@echo "Building Lambda layer with Docker (Python 3.12)..."
	docker run --rm \
		-v $$(pwd)/lambdas/layers:/var/task \
		-w /var/task \
		public.ecr.aws/lambda/python:3.12 \
		/bin/bash -c " \
			pip install --target python/lib/python3.12/site-packages -r requirements.txt && \
			zip -r dist/ai-ppt-assistant-dependencies.zip python/ \
		"
	@echo "âœ… Lambda layer built with Docker"

# Help for optimized commands
help-optimize:
	@echo "Optimized deployment commands:"
	@echo "  make fast-deploy      - Fast deployment with caching and parallelism"
	@echo "  make deploy-prod      - Production deployment (skip test functions)"
	@echo "  make deploy-incremental - Deploy only changed Lambda functions"
	@echo "  make build-layers-docker - Build layers with Docker for compatibility"
	@echo "  make clean-layer-cache - Clean the layer cache"